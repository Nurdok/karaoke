<!DOCTYPE html>
<html>
<head>
    <title>Song Rating</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }

        .song-container {
            margin: 50px auto;
            width: 400px;
        }

        h1 {
            margin-bottom: 0;
        }

        h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }

        p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .rating-buttons {
            display: flex;
            justify-content: space-between;
            column-gap: 5px;
        }

        .rating-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="song-container">
    <p>{{ user.name }}, How well do you know this song?</p>
    <h1 id="song-title">Loading...</h1>
    <h3 id="song-artist"></h3>
    <p id="song-id" style="visibility: hidden"></p>
    <div class="rating-buttons">
        <button class="rating-button" onclick="rateSong(1)">I don't know this song<br/>(1)</button>
        <button class="rating-button" onclick="rateSong(2)">I can sing along<br/>(2)</button>
        <button class="rating-button" onclick="rateSong(3)">I can take the mic<br/>(3)</button>
        <button class="rating-button" onclick="rateSong(4)">I NEED THE MIC<br/>(4)</button>
    </div>
    <div id="previous-song-container">
        <p><small>You rated <b id="previous-song-title"></b> by <b id="previous-song-artist"></b> as "<span id="previous-song-rating"></span>"</small></p>
        <button onclick="undoRating()">Undo (<kbd>Ctrl</kbd>+<kbd>z</kbd>)</button>
    </div>
</div>

<script>
    const userId = '{{ user.id }}';
    let songStack = [];

    document.addEventListener('keydown', function (event) {
        switch (event.key) {
            case '1':
                rateSong(1);
                break;
            case '2':
                rateSong(2);
                break;
            case '3':
                rateSong(3);
                break;
            case '4':
                rateSong(4);
                break;
            case 'z':
                if (event.ctrlKey) {
                    undoRating();
                }
                break;
        }
    });

    function toRatingEnumString(rating_int) {
        switch (rating_int) {
            case 0:
                return 'UNKNOWN';
            case 1:
                return 'DONT_KNOW';
            case 2:
                return 'SING_ALONG';
            case 3:
                return 'CAN_TAKE_THE_MIC';
            case 4:
                return 'NEED_THE_MIC';
        }
    }

    function toRatingDisplayString(rating_int) {
        switch (rating_int) {
            case 0:
                return 'Unknown';
            case 1:
                return 'I don\'t know this song';
            case 2:
                return 'I can sing along';
            case 3:
                return 'I can take the mic';
            case 4:
                return 'I NEED THE MIC';
        }
    }

    function rateSong(rating) {
        let ratingString = toRatingEnumString(rating)
        songStack.slice(-1)[0].rating = rating;
        const data = {
            userId: userId,
            songId: songStack.slice(-1)[0].id,
            rating: ratingString
        };

        fetch('/api/rate-song', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
                .then(response => {
                    if (response.ok) {
                        if (ratingString !== "UNKNOWN") {
                            getNextSong();
                        }
                        updateSongDetails();
                    } else {
                        console.error('Error rating song:', response.status);
                    }
                })
                .catch(error => {
                    console.error('Error rating song:', error);
                });
    }

    function updateSongDetails() {
        console.log(songStack);
        document.getElementById('song-title').textContent = songStack.slice(-1)[0].title;
        document.getElementById('song-artist').textContent = songStack.slice(-1)[0].artist;

        if (songStack.length <= 1) {
            document.getElementById('previous-song-container').setAttribute("style", "visibility: hidden")
            return;
        }

        document.getElementById('previous-song-container').setAttribute("style", "visibility: visible")
        document.getElementById('previous-song-title').textContent = songStack.slice(-2)[0].title;
        document.getElementById('previous-song-artist').textContent = songStack.slice(-2)[0].artist;
        document.getElementById('previous-song-rating').textContent = toRatingDisplayString(songStack.slice(-2)[0].rating);
    }

    function getNextSong() {
        fetch('/api/next-unrated-song?u={{ user.id }}')
                .then(response => response.json())
                .then(song => {
                    songStack.push({
                        id: song.song_id,
                        title: song.song_title,
                        artist: song.song_artist,
                        rating: 0
                    });
                    updateSongDetails();
                })
                .catch(error => {
                    console.error('Error fetching next song:', error);
                });
    }

    function undoRating() {
        songStack.pop();
        rateSong(0);
    }

    // Initial request to get the first song
    getNextSong();
</script>
</body>
</html>
